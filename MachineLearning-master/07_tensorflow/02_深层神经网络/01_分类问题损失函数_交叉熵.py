'''

经典的损失函数----交叉熵



1 交叉熵:
　　分类问题中使用比较广泛的一种损失函数, 它刻画两个概率分布之间的距离
　　给定两个概率分布p和q, 交叉熵为:　　H(p, q) = -∑ p(x) log q(x)

　　当事件总数是一定的时候， 概率函数满足：   任意x  p(X = x) ﻿∈[0, 1] 且 Σ p(X=x) = 1

　　也就是说 所有时间发生的概率都是0到1 之间 ， 且总有一个时间会发生，概率的和就为1。



2 tensorflow中softmax：

　　softmax回归可以作为学习算法来优化分类结果，在tensorflow中，softmax回归的参数被去掉了，它将神经网络输出变成一个概率分布。

　　假设原始神经网络输出为 y1, y2, y3, ... , yn

　　softmax 处理后的输出为： softmax(y)i = yi' = eyi / Σj=1n eyj

　　原始神经网络的输出被用作置信度来生成新的输出，新的输出满足概率分布所有要求

　　这样就可以通过交叉熵来衡量预测概率分布和真实概率分布的距离



3 从交叉熵的公式可以看出，它表达的是通过概率函数q来表达概率分布p的困难程度。

　　交叉熵作为神经网络的损失函数的时候，q代表预测值， p代表真实值，交叉熵刻画两个分布的距离

　　也就是交叉熵的值越小，两个概率分布越近



4 举例：

　　假设有一个三分类问题，某个样例的正确答案是(1, 0, 0)

　　

　　经过softmax后的预测答案是(0.5, 0.4, 0.1)

　　那么它和正确答案的交叉熵为： H( (1,0,0) , (0.5,0.4,0.1) ) = - ( 1*log0.5 + 0*log0.4 + 0*log0.1 ) ≈ 0.3

　　

　　另一个经过softmax的预测值是(0.8, 0.1, 0.1)

　　他和正确答案的交叉熵是 ： H( (1, 0, 0), (0.8, 0.1, 0.1) ) = - ( 1*log0.8 + 0*log0.1 + 0*log0.1 ) ≈ 0.1



从直观上看 容易知道第二个优于第一个，通过交叉熵计算结果也是一致的。





在tensorflow中 使用如下代码实现计算交叉熵：

　　cross_entropy = -tf.reduce_mean(y_ * tf.log(tf.clip_by_value(y, 1e-10, 1.0)))

　　其中 y_为真实值

　　　　y 为预测值

　　　　tf.clip_by_value(y, 1e-10, 1.0) 能够把y的值限定在1e-10和1.0之间，

　　　　　　y如果小于1e-10 函数返回1e-10， 如果大于1.0 返回1.0， 如果在这之间就返回y

　　　　　　这样做的目的是防止出现log0 的情况

　　　　tf.log 为计算log函数

　　　　* 操作不是矩阵乘法， 是对应位置元素的乘法

　　　　tf.reduce_mean 取平均数。  如果衡量大小，和取和是一样的。



一般交叉熵会和sotmax回归一起使用，在tensorflow中进行了一起封装为：

　　cross_entropy = tf.nn.sotmax_cross_entropy_with_logits(y, y_)

　　　　其中y为预测值，y_为真实值



在只有一个正确答案的情况下，tensorflow提供了 加速计算函数

　　tf.nn.sparse_softmax_cross_entropy_with_logits

　　　　　　

'''